// Package main provides application commands for the CLI.
package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/commedesvlados/anki-flashcards-autogen-cli/internal/app"
	"github.com/commedesvlados/anki-flashcards-autogen-cli/pkg/common"
	"github.com/commedesvlados/anki-flashcards-autogen-cli/pkg/logger"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
)

type makeApkgOptions struct {
	inputExcelFile string
	outputAkgFile  string
	unsplashKey    string
	deckName       string
	mediaDir       string
	enrichedDir    string
	noMediaCache   bool
}

// NewMakeApkgCmd returns the make-apkg cobra command.
func NewMakeApkgCmd() *cobra.Command {
	opts := &makeApkgOptions{}
	var progressBar bool
	var verbose bool
	cmd := &cobra.Command{
		Use:   "make-apkg",
		Short: "Create a new Anki .apkg file from Excel data",
		Run: func(cmd *cobra.Command, _ []string) {
			// Get global flags
			progressBar, _ = cmd.Root().PersistentFlags().GetBool("progress")
			verbose, _ = cmd.Root().PersistentFlags().GetBool("verbose")
			runMakeApkg(cmd, opts, progressBar, verbose)
		},
	}
	cmd.Flags().StringVarP(&opts.inputExcelFile, "input", "i", "data/words.xlsx", "Path to Excel file with word pairs")
	cmd.Flags().StringVarP(&opts.outputAkgFile, "output", "o", "output/vocab.apkg", "Output Anki package file")
	cmd.Flags().StringVar(&opts.unsplashKey, "unsplash", "", "Unsplash API access key (or set UNSPLASH_API_KEY env var)")
	cmd.Flags().StringVar(&opts.deckName, "deck", "Designed Autogenerated RU-EN Vocabulary", "Name of the Anki deck")
	cmd.Flags().StringVar(&opts.mediaDir, "media", "media", "Directory for downloaded media files")
	cmd.Flags().StringVar(&opts.enrichedDir, "enriched", "enriched", "Directory for enriched JSON data")
	cmd.Flags().BoolVar(&opts.noMediaCache, "no-media-cache", false, "Delete all files in media/ after .apkg is built")
	return cmd
}

func runMakeApkg(_ *cobra.Command, opts *makeApkgOptions, progressBar, verbose bool) {
	log := logger.SetupLogger(verbose)
	defer func() {
		if err := log.Sync(); err != nil {
			fmt.Fprintf(os.Stderr, "logger.Sync error: %v\n", err)
		}
	}()

	unsplashKey := opts.unsplashKey
	if unsplashKey == "" {
		unsplashKey = os.Getenv("UNSPLASH_API_KEY")
	}
	if unsplashKey == "" {
		log.Fatal("Unsplash API key is required. Use --unsplash flag or set UNSPLASH_API_KEY environment variable.") //nolint:gocritic
	}

	finalOutputFile := opts.outputAkgFile
	if finalOutputFile == "output/vocab.apkg" {
		deckFileName := common.RemoveSpaces(opts.deckName) + ".apkg"
		finalOutputFile = "output/" + deckFileName
	}

	dirs := []string{opts.mediaDir, opts.enrichedDir, filepath.Dir(finalOutputFile)}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil { //nolint:mnd
			log.Fatal("Failed to create directory", zap.String("dir", dir), zap.Error(err))
		}
	}

	config := &app.ApkgMakerConfig{
		ExcelFile:    opts.inputExcelFile,
		MediaDir:     opts.mediaDir,
		EnrichedDir:  opts.enrichedDir,
		OutputFile:   finalOutputFile,
		UnsplashKey:  unsplashKey,
		ProgressBar:  progressBar,
		DeckName:     opts.deckName,
		NoMediaCache: opts.noMediaCache,
	}

	application := app.NewApkgMaker(config, log)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute) //nolint:mnd
	defer cancel()

	if err := application.Run(ctx); err != nil {
		log.Fatal("Application failed", zap.Error(err))
	}

	log.Info("Application completed successfully")
}
